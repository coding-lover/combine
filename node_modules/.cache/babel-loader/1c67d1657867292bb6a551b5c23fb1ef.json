{"remainingRequest":"/Users/zou/data/www/combine/node_modules/thread-loader/dist/cjs.js!/Users/zou/data/www/combine/node_modules/babel-loader/lib/index.js!/Users/zou/data/www/combine/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/zou/data/www/combine/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/zou/data/www/combine/node_modules/v-folder/src/index.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/zou/data/www/combine/node_modules/v-folder/src/index.vue","mtime":1666008380000},{"path":"/Users/zou/data/www/combine/babel.config.js","mtime":1618905572000},{"path":"/Users/zou/data/www/combine/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/zou/data/www/combine/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/zou/data/www/combine/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/Users/zou/data/www/combine/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/zou/data/www/combine/node_modules/vue-loader/lib/index.js","mtime":1655715099000}],"contextDependencies":[],"result":["import _defineProperty from \"/Users/zou/data/www/combine/node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty.js\";\nimport \"core-js/modules/es6.array.map\";\nimport \"core-js/modules/es6.function.name\";\nimport Store from \"./store\";\nimport EventMixin from \"./mixin\";\nimport VNode from \"./v-node.vue\";\nimport VLeaf from \"./v-leaf.vue\";\nimport VBranch from \"./v-branch.vue\";\nimport styles from \"./styles.css\";\nvar uid = 0;\nexport default {\n  name: 'v-folder',\n  mixins: [EventMixin],\n  props: {\n    data: Object,\n    ajax: Function,\n    conf: Object\n  },\n  components: {\n    'v-node': VNode,\n    'v-leaf': VLeaf,\n    'v-branch': VBranch\n  },\n  watch: {\n    data: function data(newVal, oldVal) {\n      var nameKey = this.conf && this.conf.node || 'name';\n      if (newVal[nameKey] !== oldVal[nameKey]) {\n        this.store = new Store(newVal, this.conf);\n      }\n    }\n  },\n  data: function data() {\n    return {\n      uid: uid++,\n      store: new Store(this.data, this.conf)\n    };\n  },\n  computed: {\n    root: function root() {\n      return this.store.dataStore;\n    },\n    branches: function branches() {\n      return this.root.branches;\n    },\n    leafs: function leafs() {\n      return this.root.leafs;\n    },\n    node: function node() {\n      return this.root.node;\n    }\n  },\n  methods: {\n    resTransform: function resTransform(data, node) {\n      //debugger\n      var conf = this.conf || {};\n      var dirKey = conf['branch'] || 'dirs';\n      var fileKey = conf['leaf'] || 'files';\n      var nameKey = conf['node'] || 'name';\n      data[nameKey] = node.name;\n      data[dirKey] = data[dirKey].map(function (d) {\n        return _defineProperty({}, nameKey, d);\n      });\n      return data;\n    },\n    getReqConf: function getReqConf(node) {\n      var reqConf = this.ajax || {};\n      var url = reqConf.url,\n        method = reqConf.method,\n        data = reqConf.data,\n        params = reqConf.params,\n        pathAs = reqConf.pathAs,\n        headers = reqConf.headers;\n      if (method || method.toUpperCase() === 'GET') {\n        reqConf.params = params || {};\n        reqConf.params[pathAs] = node.path;\n      } else {\n        reqConf.data = data || {};\n        reqConf.data[pathAs] = node.path;\n      }\n      reqConf.method = method || 'GET';\n      reqConf.headers = headers || {};\n      return reqConf;\n    },\n    request: function request(node) {\n      var _this = this;\n      if (!this.ajax) {\n        return Promise.reject('ajax:false');\n      }\n      if (typeof this.ajax == 'function') {\n        return this.ajax(node).then(function (data) {\n          return _this.resTransform(data, node);\n        });\n      }\n      var process = this.ajax.process || function (res) {\n        return res;\n      };\n      return this.$http(this.getReqConf(node)).then(function (res) {\n        var data = process(res.data);\n        return _this.resTransform(data, node);\n      });\n    }\n  },\n  created: function created() {\n    var _this2 = this;\n    this.listen('change', function (node) {\n      //debugger\n      _this2.store.commit('change', node).then(function (res) {\n        return _this2.$emit('change', res);\n      });\n    });\n    this.listen('unfold', function (node) {\n      if (node.open && node.canOpen) {\n        node.open = !node.open;\n        return;\n      }\n      _this2.store.commit('unfold', node).then(function () {\n        _this2.request(node).then(function (data) {\n          if (data) {\n            _this2.store.merge(data, node);\n          } else {\n            throw 'empty';\n          }\n        }).catch(function (e) {\n          node.status = 'empty';\n          window.console && console.error(e);\n        });\n      }).catch(function (e) {\n        node.status = 'done';\n      });\n    });\n  },\n  destroyed: function destroyed() {\n    this.distroy();\n  }\n};",{"version":3,"mappings":";;;AAQA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;EACAA;EACAC;EACAC;IACAC;IACAC;IACAC;EACA;EACAC;IACA;IACA;IACA;EACA;EACAC;IACAJ;MACA;MACA;QACA;MACA;IACA;EACA;EACAA;IACA;MACAK;MACAC;IACA;EACA;EAEAC;IACAC;MACA;IACA;IACAC;MACA;IACA;IACAC;MACA;IACA;IACAC;MACA;IACA;EACA;EAEAC;IACAC;MACA;MACA;MACA;MACA;MACA;MAEAb;MACAA;QAAA;MAAA;MACA;IACA;IAEAc;MACA;MACA;QAAAC;QAAAf;QAAAgB;QAAAC;QAAAC;MAEA;QACAC;QACAA;MACA;QACAA;QACAA;MACA;MAEAA;MACAA;MAEA;IACA;IAEAC;MAAA;MACA;QACA;MACA;MAEA;QACA;UACA;QACA;MACA;MAEA;QAAA;MAAA;MAEA,yCACAC;QACA;QACA;MACA;IACA;EACA;EAEAC;IAAA;IACA;MACA;MACA,aACAC,uBACAF;QAAA;MAAA;IACA;IAEA;MACA;QACAV;QACA;MACA;MAEA,aACAY,uBACAF;QAEA,qBACAA;UACA;YACA;UACA;YACA;UACA;QACA,GACAG;UACAb;UACAc;QACA;MAEA,GACAD;QACAb;MACA;IAEA;EACA;EACAe;IACA;EACA;AACA","names":["name","mixins","props","data","ajax","conf","components","watch","uid","store","computed","root","branches","leafs","node","methods","resTransform","getReqConf","method","params","pathAs","headers","reqConf","request","then","created","commit","catch","window","destroyed"],"sourceRoot":"node_modules/v-folder/src","sources":["index.vue"],"sourcesContent":["<template>\n  <ul class=\"v-branch-body\">\n    <v-node :data=\"node\" :uid=\"uid\"></v-node>\n    <v-branch v-show=\"node.open\" v-for=\"branch in branches\" :data=\"branch\" :uid=\"uid\"></v-branch>\n    <v-leaf v-show=\"node.open\" v-for=\"leaf in leafs\" :data=\"leaf\" :uid=\"uid\"></v-leaf>\n  </ul>\n</template>\n<script>\n  import Store from './store'\n  import EventMixin from './mixin'\n  import VNode from './v-node.vue'\n  import VLeaf from './v-leaf.vue'\n  import VBranch from './v-branch.vue'\n  import styles from './styles.css'\n\n  let uid = 0\n\n  export default {\n    name: 'v-folder',\n    mixins: [EventMixin],\n    props: {\n      data: Object,\n      ajax: Function,\n      conf: Object\n    },\n    components: {\n      'v-node': VNode,\n      'v-leaf': VLeaf,\n      'v-branch': VBranch\n    },\n    watch: {\n      data(newVal, oldVal) {\n        let nameKey = this.conf && this.conf.node || 'name'\n        if (newVal[nameKey] !== oldVal[nameKey]) {\n          this.store = new Store(newVal, this.conf)\n        }\n      }\n    },\n    data() {\n      return {\n        uid: uid++,\n        store: new Store(this.data, this.conf)\n      }\n    },\n\n    computed: {\n      root() {\n        return this.store.dataStore\n      },\n      branches() {\n        return this.root.branches\n      },\n      leafs() {\n        return this.root.leafs\n      },\n      node() {\n        return this.root.node\n      }\n    },\n\n    methods: {\n      resTransform(data, node) {\n        //debugger\n        let conf = this.conf || {}\n        let dirKey  = conf['branch'] || 'dirs'\n        let fileKey = conf['leaf'] || 'files'\n        let nameKey = conf['node'] || 'name'\n\n        data[nameKey] = node.name\n        data[dirKey]  = data[dirKey].map(d => ({[nameKey]: d}))\n        return data\n      },\n\n      getReqConf(node) {\n        let reqConf = this.ajax || {}\n        let { url, method, data, params, pathAs, headers } = reqConf\n\n        if (method || method.toUpperCase() === 'GET') {\n          reqConf.params = (params || {})\n          reqConf.params[pathAs] = node.path\n        } else {\n          reqConf.data = (data || {})\n          reqConf.data[pathAs] = node.path\n        }\n\n        reqConf.method = method || 'GET'\n        reqConf.headers = headers || {}\n\n        return reqConf\n      },\n\n      request(node) {\n        if (!this.ajax) {\n          return Promise.reject('ajax:false')\n        }\n\n        if(typeof this.ajax == 'function') {\n            return this.ajax(node).then(data => {\n                return this.resTransform(data, node);\n            });\n        }\n\n        let process = this.ajax.process || (res => res)\n\n        return this.$http(this.getReqConf(node))\n          .then(res => {\n            let data = process(res.data)\n            return this.resTransform(data, node)\n          })\n      }\n    },\n\n    created() {\n      this.listen('change', node => {\n        //debugger\n        this.store\n          .commit('change', node)\n          .then(res => this.$emit('change', res))\n      })\n\n      this.listen('unfold', node => {\n        if (node.open && node.canOpen) {\n          node.open =! node.open\n          return\n        }\n\n        this.store\n          .commit('unfold', node)\n          .then(() => {\n\n            this.request(node)\n            .then(data => {\n              if (data) {\n                this.store.merge(data, node)\n              } else {\n                throw 'empty'\n              }\n            })\n            .catch(e => {\n              node.status = 'empty'\n              window.console && console.error(e)\n            })\n\n          })\n          .catch(e => {\n            node.status = 'done'\n          })\n\n      })\n    },\n    destroyed () {\n      this.distroy()\n    }\n  }\n</script>\n"]}]}