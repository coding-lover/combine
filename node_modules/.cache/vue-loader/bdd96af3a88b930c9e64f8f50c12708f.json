{"remainingRequest":"/Users/zou/data/www/combine/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/zou/data/www/combine/node_modules/v-folder/src/index.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/zou/data/www/combine/node_modules/v-folder/src/index.vue","mtime":1666008380000},{"path":"/Users/zou/data/www/combine/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/Users/zou/data/www/combine/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/zou/data/www/combine/node_modules/vue-loader/lib/index.js","mtime":1655715099000}],"contextDependencies":[],"result":["\n  import Store from './store'\n  import EventMixin from './mixin'\n  import VNode from './v-node.vue'\n  import VLeaf from './v-leaf.vue'\n  import VBranch from './v-branch.vue'\n  import styles from './styles.css'\n\n  let uid = 0\n\n  export default {\n    name: 'v-folder',\n    mixins: [EventMixin],\n    props: {\n      data: Object,\n      ajax: Function,\n      conf: Object\n    },\n    components: {\n      'v-node': VNode,\n      'v-leaf': VLeaf,\n      'v-branch': VBranch\n    },\n    watch: {\n      data(newVal, oldVal) {\n        let nameKey = this.conf && this.conf.node || 'name'\n        if (newVal[nameKey] !== oldVal[nameKey]) {\n          this.store = new Store(newVal, this.conf)\n        }\n      }\n    },\n    data() {\n      return {\n        uid: uid++,\n        store: new Store(this.data, this.conf)\n      }\n    },\n\n    computed: {\n      root() {\n        return this.store.dataStore\n      },\n      branches() {\n        return this.root.branches\n      },\n      leafs() {\n        return this.root.leafs\n      },\n      node() {\n        return this.root.node\n      }\n    },\n\n    methods: {\n      resTransform(data, node) {\n        //debugger\n        let conf = this.conf || {}\n        let dirKey  = conf['branch'] || 'dirs'\n        let fileKey = conf['leaf'] || 'files'\n        let nameKey = conf['node'] || 'name'\n\n        data[nameKey] = node.name\n        data[dirKey]  = data[dirKey].map(d => ({[nameKey]: d}))\n        return data\n      },\n\n      getReqConf(node) {\n        let reqConf = this.ajax || {}\n        let { url, method, data, params, pathAs, headers } = reqConf\n\n        if (method || method.toUpperCase() === 'GET') {\n          reqConf.params = (params || {})\n          reqConf.params[pathAs] = node.path\n        } else {\n          reqConf.data = (data || {})\n          reqConf.data[pathAs] = node.path\n        }\n\n        reqConf.method = method || 'GET'\n        reqConf.headers = headers || {}\n\n        return reqConf\n      },\n\n      request(node) {\n        if (!this.ajax) {\n          return Promise.reject('ajax:false')\n        }\n\n        if(typeof this.ajax == 'function') {\n            return this.ajax(node).then(data => {\n                return this.resTransform(data, node);\n            });\n        }\n\n        let process = this.ajax.process || (res => res)\n\n        return this.$http(this.getReqConf(node))\n          .then(res => {\n            let data = process(res.data)\n            return this.resTransform(data, node)\n          })\n      }\n    },\n\n    created() {\n      this.listen('change', node => {\n        //debugger\n        this.store\n          .commit('change', node)\n          .then(res => this.$emit('change', res))\n      })\n\n      this.listen('unfold', node => {\n        if (node.open && node.canOpen) {\n          node.open =! node.open\n          return\n        }\n\n        this.store\n          .commit('unfold', node)\n          .then(() => {\n\n            this.request(node)\n            .then(data => {\n              if (data) {\n                this.store.merge(data, node)\n              } else {\n                throw 'empty'\n              }\n            })\n            .catch(e => {\n              node.status = 'empty'\n              window.console && console.error(e)\n            })\n\n          })\n          .catch(e => {\n            node.status = 'done'\n          })\n\n      })\n    },\n    destroyed () {\n      this.distroy()\n    }\n  }\n",{"version":3,"sources":["index.vue"],"names":[],"mappings":";AAQA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"node_modules/v-folder/src","sourcesContent":["<template>\n  <ul class=\"v-branch-body\">\n    <v-node :data=\"node\" :uid=\"uid\"></v-node>\n    <v-branch v-show=\"node.open\" v-for=\"branch in branches\" :data=\"branch\" :uid=\"uid\"></v-branch>\n    <v-leaf v-show=\"node.open\" v-for=\"leaf in leafs\" :data=\"leaf\" :uid=\"uid\"></v-leaf>\n  </ul>\n</template>\n<script>\n  import Store from './store'\n  import EventMixin from './mixin'\n  import VNode from './v-node.vue'\n  import VLeaf from './v-leaf.vue'\n  import VBranch from './v-branch.vue'\n  import styles from './styles.css'\n\n  let uid = 0\n\n  export default {\n    name: 'v-folder',\n    mixins: [EventMixin],\n    props: {\n      data: Object,\n      ajax: Function,\n      conf: Object\n    },\n    components: {\n      'v-node': VNode,\n      'v-leaf': VLeaf,\n      'v-branch': VBranch\n    },\n    watch: {\n      data(newVal, oldVal) {\n        let nameKey = this.conf && this.conf.node || 'name'\n        if (newVal[nameKey] !== oldVal[nameKey]) {\n          this.store = new Store(newVal, this.conf)\n        }\n      }\n    },\n    data() {\n      return {\n        uid: uid++,\n        store: new Store(this.data, this.conf)\n      }\n    },\n\n    computed: {\n      root() {\n        return this.store.dataStore\n      },\n      branches() {\n        return this.root.branches\n      },\n      leafs() {\n        return this.root.leafs\n      },\n      node() {\n        return this.root.node\n      }\n    },\n\n    methods: {\n      resTransform(data, node) {\n        //debugger\n        let conf = this.conf || {}\n        let dirKey  = conf['branch'] || 'dirs'\n        let fileKey = conf['leaf'] || 'files'\n        let nameKey = conf['node'] || 'name'\n\n        data[nameKey] = node.name\n        data[dirKey]  = data[dirKey].map(d => ({[nameKey]: d}))\n        return data\n      },\n\n      getReqConf(node) {\n        let reqConf = this.ajax || {}\n        let { url, method, data, params, pathAs, headers } = reqConf\n\n        if (method || method.toUpperCase() === 'GET') {\n          reqConf.params = (params || {})\n          reqConf.params[pathAs] = node.path\n        } else {\n          reqConf.data = (data || {})\n          reqConf.data[pathAs] = node.path\n        }\n\n        reqConf.method = method || 'GET'\n        reqConf.headers = headers || {}\n\n        return reqConf\n      },\n\n      request(node) {\n        if (!this.ajax) {\n          return Promise.reject('ajax:false')\n        }\n\n        if(typeof this.ajax == 'function') {\n            return this.ajax(node).then(data => {\n                return this.resTransform(data, node);\n            });\n        }\n\n        let process = this.ajax.process || (res => res)\n\n        return this.$http(this.getReqConf(node))\n          .then(res => {\n            let data = process(res.data)\n            return this.resTransform(data, node)\n          })\n      }\n    },\n\n    created() {\n      this.listen('change', node => {\n        //debugger\n        this.store\n          .commit('change', node)\n          .then(res => this.$emit('change', res))\n      })\n\n      this.listen('unfold', node => {\n        if (node.open && node.canOpen) {\n          node.open =! node.open\n          return\n        }\n\n        this.store\n          .commit('unfold', node)\n          .then(() => {\n\n            this.request(node)\n            .then(data => {\n              if (data) {\n                this.store.merge(data, node)\n              } else {\n                throw 'empty'\n              }\n            })\n            .catch(e => {\n              node.status = 'empty'\n              window.console && console.error(e)\n            })\n\n          })\n          .catch(e => {\n            node.status = 'done'\n          })\n\n      })\n    },\n    destroyed () {\n      this.distroy()\n    }\n  }\n</script>\n"]}]}